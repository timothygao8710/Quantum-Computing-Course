//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Intrinsic.Interfaces;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Empty\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":32,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"classicalBits\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":22},\"Item2\":{\"Line\":1,\"Column\":35}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":46},\"Item2\":{\"Line\":1,\"Column\":54}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" - Why is flipping the <000| nessesary? Shouldn't it be 0 according to the hada matrix\",\"\",\"\",\" # Summary\",\" In this exercise, you are given a classical bit array and a qubit\",\" register. Both are of unknown length, but they have the same length.\",\" Your goal is to apply the bitwise XOR operation in-place on the\",\" quantum register, using its own state and the classical bit array as\",\" the two input arguments, and using the register itself as the output.\",\" For example, if the classical bit array is 10110 and the qubit\",\" register is in the state |00101>, then this operation should put the\",\" qubit register into the state 10110 XOR 00101 = |10011>.\",\"\",\" # Input\",\" ## classicalBits\",\" A classical bit array that contains an unknown bit string of unknown\",\" length.\",\"\",\" ## register\",\" A qubit array in an unknown state, which has the same length as the\",\" classicalBits array.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":32,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":32,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":2,\"Column\":8},\"Item2\":{\"Line\":2,\"Column\":11}},\"Documentation\":[\"automatically generated QsAdjoint specialization for Lab6.Exercise1\"]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise2\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":56,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":22},\"Item2\":{\"Line\":1,\"Column\":30}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":42},\"Item2\":{\"Line\":1,\"Column\":48}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement an oracle that checks if all of\",\" the provided qubits are in the |0> state. You are given a qubit\",\" register of unknown length in an unknown state, and a target qubit\",\" that is in the |1> state. Your goal is to phase-flip the target qubit\",\" if the register is in the state |0...0>.\",\"\",\" # Input\",\" ## register\",\" A register of unknown length in an unknown state.\",\"\",\" ## target\",\" The target qubit that you must phase-flip if the register is in the\",\" |0...0> state. The target qubit will be provided in the |1> state.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise2\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":56,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise3\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":100,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"originalMessage\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":24}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"encryptedMessage\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":25}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"candidateEncryptionKey\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":31}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement an oracle that checks to see if a\",\" provided encryption key is correct. You are given an original message\",\" as a classical bit string and the message after it has been encrypted\",\" with an unknown encryption key. The encryption algorithm is a bitwise\",\" XOR. You are also given a qubit register which represents the\",\" encryption key being checked, and a target qubit. Your goal is to\",\" phase-flip the target qubit if the state of the qubit register\",\" corresponds to the encryption key that was used to encrypt the\",\" original message.\",\"\",\" # Input\",\" ## originalMessage\",\" A classical bitstring containing the original message that was\",\" encrypted.\",\"\",\" ## encryptedMessage\",\" A classical bitstring containing the original message after it was\",\" encrypted with a bitwise XOR algorithm.\",\"\",\" ## candidateEncryptionKey\",\" A quantum register containing the potential encryption key that is\",\" being checked by your oracle - think of it like a quantum version of\",\" the classical encryption key.\",\"\",\" ## target\",\" The qubit that you should phase-flip if the candidate key is the\",\" correct key - that is, if encrypting the original message with it\",\" produces the same bitstring as the encryptedMessage bitstring.\",\"\",\" # Remarks\",\" Obviously, bitwise XOR is a trivial example because you can just XOR\",\" the original message with the encrypted message to recover the\",\" encryption key. The point of this exercise is to show that this\",\" process can be done with any algorithm, including ones that are\",\" nontrivial like modern cryptographic cyphers (SHA256, AES, etc.). XOR\",\" is just used here because it's easy to implement, think of it as a\",\" proof-of-concept.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise3\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":100,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise4\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":141,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"oracle\"]},\"Type\":{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":15}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":17}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement the repeated quantum iteration in\",\" Grover's algorithm, which consists of running the oracle and then the\",\" diffusion operator. You are given an oracle to run, a qubit register\",\" representing the input to the oracle, and a target qubit that the\",\" oracle can use for phase-flipping if provided with the correct input.\",\"\",\" # Input\",\" ## oracle\",\" A function object representing the oracle being used during the search\",\" to find the \\\"correct\\\" state. You can run it with the following syntax:\",\"     oracle(Register, Target);\",\"\",\" ## register\",\" A qubit register of unknown length and unknown state. This represents\",\" the input you should provide to the oracle.\",\"\",\" ## target\",\" A qubit in the |1> state. This represents a target you can use for any\",\" phase-flipping oracles.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise4\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":141,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise5\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Transparent\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":175,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"oracle\"]},\"Type\":{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":15}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numberOfQubits\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":23}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement Grover's quantum search\",\" algorithm. You have already implemented all of the pieces, so now you\",\" just need to put them all together. You are given an oracle which can\",\" correctly identify the \\\"correct\\\" answer to the problem being searched,\",\" and a number of qubits that it expects for its input register. Your\",\" goal is to use this information to run Grover's search and find the\",\" correct state.\",\"\",\" # Input\",\" ## oracle\",\" A phase-flipping operation that can identify the \\\"correct\\\" answer to a\",\" problem by giving it a negative amplitude.\",\"\",\" ## numberOfQubits\",\" The number of qubits that the oracle expects in its input register.\",\"\",\" # Output\",\" You must return a classical bit string (false for 0, true for 1) that\",\" represents the solution that the search algorithm found.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise5\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs\",\"Position\":{\"Item1\":175,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
#line hidden
namespace Lab6
{
    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Body, 33, 57)]
    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Adjoint, 33, 57)]
    public partial class Exercise1 : Adjointable<(IQArray<Boolean>,IQArray<Qubit>)>, ICallable
    {
        public Exercise1(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Boolean>,IQArray<Qubit>)>, IApplyData
        {
            public In((IQArray<Boolean>,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item2)?.Qubits;
                }
            }
        }

        String ICallable.Name => "Exercise1";
        String ICallable.FullName => "Lab6.Exercise1";
        protected ICallable Length__
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected ICallable<QRange, QRange> RangeReverse__
        {
            get;
            set;
        }

        public override Func<(IQArray<Boolean>,IQArray<Qubit>), QVoid> __Body__ => (__in__) =>
        {
            var (classicalBits,register) = __in__;
#line 35 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            foreach (var i in new QRange(0L, (register.Length - 1L)))
#line hidden
            {
#line 36 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                if (classicalBits[i])
                {
#line 37 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Apply(register[i]);
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Boolean>,IQArray<Qubit>), QVoid> __AdjointBody__ => (__in__) =>
        {
            var (classicalBits,register) = __in__;
#line 33 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            foreach (var __qsVar0__i__ in RangeReverse__.Apply(new QRange(0L, (register.Length - 1L))))
#line hidden
            {
#line 33 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                if (classicalBits[__qsVar0__i__])
                {
#line 33 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Adjoint.Apply(register[__qsVar0__i__]);
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.RangeReverse__ = this.__Factory__.Get<ICallable<QRange, QRange>>(typeof(global::Microsoft.Quantum.Core.RangeReverse));
        }

        public override IApplyData __DataIn__((IQArray<Boolean>,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Boolean> classicalBits, IQArray<Qubit> register)
        {
            return __m__.Run<Exercise1, (IQArray<Boolean>,IQArray<Qubit>), QVoid>((classicalBits, register));
        }
    }

    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Body, 57, 101)]
    public partial class Exercise2 : Operation<(IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise2(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item1)?.Qubits, ((IApplyData)Data.Item2)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise2";
        String ICallable.FullName => "Lab6.Exercise2";
        protected ICallable Length__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Canon__ControlledOnBitString
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__Z
        {
            get;
            set;
        }

        public override Func<(IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (register,target) = __in__;
#line 58 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
#line hidden
            var __arg1__ = false;
#line 58 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            var test1 = new QArray<Boolean>(QArray.Filled(() => __arg1__, register.Length));
#line 59 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Microsoft__Quantum__Canon__ControlledOnBitString.Apply<IUnitary>((test1?.Copy(), Microsoft__Quantum__Intrinsic__Z)).Apply((register, target));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Canon__ControlledOnBitString = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ControlledOnBitString<>));
            this.Microsoft__Quantum__Intrinsic__Z = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.Z));
        }

        public override IApplyData __DataIn__((IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Qubit> register, Qubit target)
        {
            return __m__.Run<Exercise2, (IQArray<Qubit>,Qubit), QVoid>((register, target));
        }
    }

    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Body, 101, 142)]
    public partial class Exercise3 : Operation<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise3(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item3)?.Qubits, ((IApplyData)Data.Item4)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise3";
        String ICallable.FullName => "Lab6.Exercise3";
        protected IAdjointable<(IQArray<Boolean>,IQArray<Qubit>)> Exercise1__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Canon__ControlledOnBitString
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__Z
        {
            get;
            set;
        }

        public override Func<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (originalMessage,encryptedMessage,candidateEncryptionKey,target) = __in__;
#line 112 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Exercise1__.Apply((originalMessage, candidateEncryptionKey));
#line 116 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Microsoft__Quantum__Canon__ControlledOnBitString.Apply<IUnitary>((encryptedMessage, Microsoft__Quantum__Intrinsic__Z)).Apply((candidateEncryptionKey, target));
#line 118 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Exercise1__.Adjoint.Apply((originalMessage, candidateEncryptionKey));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Exercise1__ = this.__Factory__.Get<IAdjointable<(IQArray<Boolean>,IQArray<Qubit>)>>(typeof(Exercise1));
            this.Microsoft__Quantum__Canon__ControlledOnBitString = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ControlledOnBitString<>));
            this.Microsoft__Quantum__Intrinsic__Z = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.Z));
        }

        public override IApplyData __DataIn__((IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Boolean> originalMessage, IQArray<Boolean> encryptedMessage, IQArray<Qubit> candidateEncryptionKey, Qubit target)
        {
            return __m__.Run<Exercise3, (IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid>((originalMessage, encryptedMessage, candidateEncryptionKey, target));
        }
    }

    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Body, 142, 176)]
    public partial class Exercise4 : Operation<(ICallable,IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise4(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(ICallable,IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((ICallable,IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item1)?.Qubits, ((IApplyData)Data.Item2)?.Qubits, ((IApplyData)Data.Item3)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise4";
        String ICallable.FullName => "Lab6.Exercise4";
        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected ICallable<(IQArray<Qubit>,Qubit), QVoid> Exercise2__
        {
            get;
            set;
        }

        public override Func<(ICallable,IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (oracle,register,target) = __in__;
#line 149 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            oracle.Apply((register, target));
#line 150 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line 151 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Exercise2__.Apply((register, target));
#line 152 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Exercise2__ = this.__Factory__.Get<ICallable<(IQArray<Qubit>,Qubit), QVoid>>(typeof(Exercise2));
        }

        public override IApplyData __DataIn__((ICallable,IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, ICallable oracle, IQArray<Qubit> register, Qubit target)
        {
            return __m__.Run<Exercise4, (ICallable,IQArray<Qubit>,Qubit), QVoid>((oracle, register, target));
        }
    }

    [SourceLocation("/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs", OperationFunctor.Body, 176, -1)]
    public partial class Exercise5 : Operation<(ICallable,Int64), IQArray<Boolean>>, ICallable
    {
        public Exercise5(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(ICallable,Int64)>, IApplyData
        {
            public In((ICallable,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item1)?.Qubits;
                }
            }
        }

        String ICallable.Name => "Exercise5";
        String ICallable.FullName => "Lab6.Exercise5";
        protected ICallable<Double, Int64> Microsoft__Quantum__Math__Round
        {
            get;
            set;
        }

        protected ICallable<(Double,Double), Double> Microsoft__Quantum__Math__PowD
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> Microsoft__Quantum__Convert__IntAsDouble
        {
            get;
            set;
        }

        protected Allocate Allocate__
        {
            get;
            set;
        }

        protected Release Release__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected ICallable<(ICallable,IQArray<Qubit>,Qubit), QVoid> Exercise4__
        {
            get;
            set;
        }

        protected ICallable<Qubit, Result> Microsoft__Quantum__Intrinsic__M
        {
            get;
            set;
        }

        protected ICallable<Qubit, QVoid> Reset__
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, QVoid> ResetAll__
        {
            get;
            set;
        }

        public override Func<(ICallable,Int64), IQArray<Boolean>> __Body__ => (__in__) =>
        {
            var (oracle,numberOfQubits) = __in__;
#line 183 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            var iterations = Microsoft__Quantum__Math__Round.Apply(Microsoft__Quantum__Math__PowD.Apply((2D, (Microsoft__Quantum__Convert__IntAsDouble.Apply(numberOfQubits) / 2D))));
#line 184 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
            var res = QArray<Boolean>.Create(0L);
#line hidden
            {
#line 185 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                var register = Allocate__.Apply(numberOfQubits);
#line hidden
                bool __arg1__ = true;
                try
                {
#line 186 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                    Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line hidden
                    {
#line 188 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                        var output = Allocate__.Apply();
#line hidden
                        bool __arg2__ = true;
                        try
                        {
#line 189 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            Microsoft__Quantum__Intrinsic__X.Apply(output);
#line 194 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            foreach (var i in new QRange(1L, iterations))
#line hidden
                            {
#line 195 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                                Exercise4__.Apply((oracle, register, output));
                            }

#line 198 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            foreach (var i in register)
#line hidden
                            {
#line 199 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                                res = QArray<Boolean>.Add(res, new QArray<Boolean>(((Microsoft__Quantum__Intrinsic__M.Apply(i) == Result.One) ? true : false)));
                            }

#line 201 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            Reset__.Apply(output);
#line 202 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            ResetAll__.Apply(register);
#line 203 "/home/ubuntu/timothys-folder/QSharpExercises/Lab6/Lab6.qs"
                            return res;
                        }
#line hidden
                        catch
                        {
                            __arg2__ = false;
                            throw;
                        }
#line hidden
                        finally
                        {
                            if (__arg2__)
                            {
#line hidden
                                Release__.Apply(output);
                            }
                        }
                    }
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release__.Apply(register);
                    }
                }
            }
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Math__Round = this.__Factory__.Get<ICallable<Double, Int64>>(typeof(global::Microsoft.Quantum.Math.Round));
            this.Microsoft__Quantum__Math__PowD = this.__Factory__.Get<ICallable<(Double,Double), Double>>(typeof(global::Microsoft.Quantum.Math.PowD));
            this.Microsoft__Quantum__Convert__IntAsDouble = this.__Factory__.Get<ICallable<Int64, Double>>(typeof(global::Microsoft.Quantum.Convert.IntAsDouble));
            this.Allocate__ = this.__Factory__.Get<Allocate>(typeof(global::Microsoft.Quantum.Intrinsic.Allocate));
            this.Release__ = this.__Factory__.Get<Release>(typeof(global::Microsoft.Quantum.Intrinsic.Release));
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.Exercise4__ = this.__Factory__.Get<ICallable<(ICallable,IQArray<Qubit>,Qubit), QVoid>>(typeof(Exercise4));
            this.Microsoft__Quantum__Intrinsic__M = this.__Factory__.Get<ICallable<Qubit, Result>>(typeof(global::Microsoft.Quantum.Intrinsic.M));
            this.Reset__ = this.__Factory__.Get<ICallable<Qubit, QVoid>>(typeof(global::Microsoft.Quantum.Intrinsic.Reset));
            this.ResetAll__ = this.__Factory__.Get<ICallable<IQArray<Qubit>, QVoid>>(typeof(global::Microsoft.Quantum.Intrinsic.ResetAll));
        }

        public override IApplyData __DataIn__((ICallable,Int64) data) => new In(data);
        public override IApplyData __DataOut__(IQArray<Boolean> data) => data;
        public static System.Threading.Tasks.Task<IQArray<Boolean>> Run(IOperationFactory __m__, ICallable oracle, Int64 numberOfQubits)
        {
            return __m__.Run<Exercise5, (ICallable,Int64), IQArray<Boolean>>((oracle, numberOfQubits));
        }
    }
}